#!/bin/sh

TEST_COMMAND="$1"

has_no_staged_changes() {
  git diff --cached --quiet
}

has_no_unstaged_changes() {
  git diff-files --quiet
}

has_no_untracked_files() {
  # --other gets untracked files
  # --exclude-standard omits files in .gitignore and such
  test -z "$(git ls-files --other --exclude-standard)"
}

restore_unstaged_untracked() {
  # git clean -d --force --quiet

  # Stash what we actually want to commit
  git stash save --quiet "pre-commit-staged-$(date +'%T-%x')"
  # Unstash original dirty tree (including untracked files)
  git stash apply 'stash@{1}' --quiet
  # Replace current index with the one from the stash; contains what we want to commit
  git read-tree stash
}


if [ -z "${TEST_COMMAND}" ]; then
  >&2 printf 'PRE-COMMIT: Test command empty, please insert one in %s to test.\n' "${GIT_DIR}/hooks/pre-commit"
  exit 0
elif has_no_staged_changes; then
  >&2 printf 'PRE-COMMIT: No staged changes; exiting.\n'
  exit 0
fi

if has_no_untracked_files && has_no_unstaged_changes; then
  # Only staged changes, so test, run, clean.
  echo 'PRE-COMMIT: No unstaged changes nor untracked files'
  # trap 'git clean -d --force --quiet' EXIT INT
else
  # --keep-index  ensure our tests use the inteded changes.
  # --include-untracked to keep our other files that might affect the build.
  git stash save \
    --keep-index \
    --include-untracked \
    --quiet \
    "pre-commit-untracked-unstaged-$(date +'%T-%x')"
  trap 'restore_unstaged_untracked' EXIT INT
fi


"${TEST_COMMAND}"
exit_status="$?"

if [ "${exit_status}" -ne '0' ]; then
  >&2 printf '\nCommand exited with non-zero status (%d).\n' "${exit_status}"
  >&2 printf "To bypass this check, use 'git commit --no-verify'\n"
fi

exit "${exit_status}"
